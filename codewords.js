Numbas.addExtension('codewords',['math','jme','jme-display'],function(codewords) {

	function set(arr,sort,eq) {
	  return arr.slice().sort(sort).reduce(function(arr,b){
		if(!arr.length || (eq ? !eq(arr[arr.length-1],b) : arr[arr.length-1]!=b)){
		  arr.push(b);
		}
		return arr;
	  },[]);
	}

	function keysort(key) {
		if(typeof(key)=='string') {
			return function(a,b) {
				return a[key]>b[key] ? 1 : a[key]<b[key] ? -1 : 0;
			}
		} else {
			return function(a,b) {
				a = key(a);
				b = key(b);
				return a>b ? 1 : a<b ? -1 : 0;
			}
		}
	}

	var Codeword = codewords.Codeword = function(digits,field_size) {
		this.field_size = field_size || 2;
		this.digits = digits || [];
		this.length = this.digits.length;
		this.asString = this.digits.join('');
	}
	Codeword.prototype = {
		toString: function() {
			return this.asString;
		},
		add: function(w2) {
			var field_size = this.field_size;
			var digits = this.digits.map(function(d1,i) {
				return (d1+w2.digits[i]) % field_size;
			});
			return new Codeword(digits,field_size);
		},
		sub: function(w2) {
			var field_size = this.field_size;
			var digits = this.digits.map(function(d1,i) {
				var r = (d1-w2.digits[i]) % field_size;
				if(r<0) {
					r += field_size;
				}
				return r;
			});
			return new Codeword(digits,field_size);
		},
		negate: function() {
			var field_size = this.field_size;
			var digits = this.digits.map(function(d) {
				return (field_size - d) % field_size;
			});
			return new Codeword(digits,field_size);
		},
		scale: function(n) {
			var field_size = this.field_size;
			n = n % field_size;
			if(n<0) {
				n += field_size;
			}
			var digits = this.digits.map(function(d) {
				return (n*d)%field_size;
			});
			return new Codeword(digits,this.field_size);
		},
		weight: function() {
			return this.digits.reduce(function(a,b){return a+(b>0?1:0)},0);
		}
	}

	Codeword.fromString = function(w,field_size) {
		w = w || '';
		var digits = w.split('').map(function(d){ return parseInt(d) });
		return new Codeword(digits,field_size);
	}
	Codeword.sort = function(a,b){
		a = a+'';
		b = b+'';
		return a>b ? 1 : a<b ? -1 : 0 
	};
	Codeword.eq = function(a,b){ return a.field_size==b.field_size && a.length==b.length && a+''==b+''; };

	var sort_by_weight = keysort(function(w){return w.weight()});

	function zero(n,field_size) {
		var digits = [];
		for(var i=0;i<n;i++) {
			digits.push(0);
		}
		return new Codeword(digits,field_size);
	}

	var allwords = codewords.allwords = function(n,field_size) {
		var l = [''];
		for(var i=0;i<n;i++) {
			var nl = [];
			l.map(function(w) {
				for(var j=0;j<field_size;j++) {
					nl.push(j+''+w);
				}
			});
			l = nl;
		}
		return l.map(function(w){ return Codeword.fromString(w,field_size) });
	}

	var set_generated_by = codewords.set_generated_by = function(basis) {
		if(!basis.length) {
			return [];
		}
		var length = basis[0].length;
		var field_size = basis[0].field_size;
		var choices = allwords(basis.length,field_size);
		generated = choices.map(function(choice) {
			var r = zero(length,field_size);
			choice.digits.map(function(f,i) {
				r = r.add(basis[i].scale(f));
			});
			return r;
		});
		return set(generated,Codeword.sort,Codeword.eq);
	}

	var linearly_independent = codewords.linearly_independent = function(words) {
		// linearly independent if the set generated by the words has (field_size)^(num_words) elements
		return set_generated_by(words).length==Math.pow(words[0].field_size,words.length);
	}

	var coset_containing = codewords.coset_containing = function(word,basis) {
		var field_size = word.field_size;
		var length = word.length;
		var combs = set_generated_by(basis);
		return combs.map(function(w2) {
			return word.add(w2);
		}).sort(sort_by_weight);
	}

	var sleppian_array = codewords.sleppian_array = function(basis) {
		if(!basis.length) {
			return [];
		}
		var field_size = basis[0].field_size;
		var length = basis[0].length;

		var base = set_generated_by(basis);
		var sets = [base];
		var seen = base.map(function(w){return w+''});
		var all = allwords(length,field_size);
		all.map(function(w) {
			if(seen.indexOf(w+'')==-1) {
				var cs = coset_containing(w,basis);
				sets.push(cs);
				seen = seen.concat(cs.map(function(w){return w+''}));
			}
		});
		return sets;
	}

	var is_coset_leader = codewords.is_coset_leader = function(word,basis) {
		var coset = coset_containing(word,basis);
		coset.sort(sort_by_weight);
		return word.weight()==coset[0].weight();
	}

	// swap the ith and jth positions in array a
	function swap(a,i,j){
		if(i==j) {
			return;
		}
		var x=Math.min(i,j);
		var y=Math.max(i,j); 
		a.splice(y,0,a.splice(x,1,a.splice(y,1)[0])[0]);
	}

	var gaussian_elimination = codewords.gaussian_elimination = function(basis) {
		basis.sort(keysort('asString'));
		var field_size = basis[0].field_size;
		var matrix = basis.slice();
		var rows = matrix.length;

		var inverses = [0,1];
		for(var i=2;i<field_size;i++) {
			for(var j=1;j<field_size;j++) {
				if((i*j)%field_size==1) {
					inverses[i]=j;
					break;
				}
			}
		}

		for(var c=0;c<rows;c++) {
			// find the first row with a non-zero in column c
			for(var i=c;i<rows;i++) {
				if(matrix[i].digits[c]!=0 && inverses[matrix[i].digits[c]]!==undefined) {
					break;
				}
			}
			if(i==rows) {
				throw(new Error('nothing in column '+row));
			}

			// multiply by the inverse of m_c,c so it has a 1 at that position
			var inv = inverses[matrix[i].digits[c]];
			matrix[i] = matrix[i].scale(inv);

			for(var row=0;row<rows;row++) {
				if(row!=i && matrix[row].digits[c]!=0) {
					matrix[row] = matrix[row].sub(matrix[i].scale(matrix[row].digits[c]));
				}
			}
		}

		return matrix;
	}

	var reduced_row_echelon_form = codewords.reduced_row_echelon_form = function(basis) {
		var field_size = basis[0].field_size;
		var matrix = basis.slice();
		var rows = matrix.length;
		var columns = matrix[0].length;

		// calculate inverses in field
		var inverses = [0,1];
		for(var i=2;i<field_size;i++) {
			for(var j=1;j<field_size;j++) {
				if((i*j)%field_size==1) {
					inverses[i]=j;
					break;
				}
			}
		}

		var current_row = 0;
		// for each column, there should be at most one row with a 1 in that column, and every other row should have 0 in that column
		for(var leader_column=0;leader_column<columns && leader_column<rows;leader_column++) {
			// find the first row with a non-zero in that column
			for(var row=leader_column;row<rows;row++) {
				if(matrix[row].digits[leader_column]!=0) {
					break;
				}
			}
			// if we found a row with a non-zero in the leader column 
			if(row<rows) {
				// swap that row with the <leader_column>th one
				if(row!=current_row) {
					var tmp = matrix[row];
					matrix[row] = matrix[current_row];
					matrix[current_row] = tmp;
				}

				// multiply this row so the leader column has a 1 in it
				var inverse = inverses[matrix[current_row].digits[leader_column]];
				matrix[current_row] = matrix[current_row].scale(inverse);

				// subtract multiples of this row from every other row so they all have a 0 in this column
				for(var row=0;row<rows;row++) {
					if(row!=current_row) {
						var original = matrix[row];
						matrix[row] = matrix[row].sub(matrix[current_row].scale(matrix[row].digits[leader_column]));
					}
				}
				current_row += 1;
			}
		}
		
		return matrix;
	}

	var parity_check_matrix = codewords.parity_check_matrix = function(basis) {
		var field_size = basis[0].field_size;
		var g = reduced_row_echelon_form(basis);
		var A = g.map(function(c){ return c.digits.slice(g.length)});
		var columns = A[0].length;
		var rows = A.length;
		var m = [];
		for(var i=0;i<columns;i++) {
			var row = [];
			for(var j=0;j<rows;j++) {
				row.push((field_size - A[j][i]) % field_size);
			}
			for(var j=0;j<columns;j++) {
				row.push(j==i ? 1 : 0);
			}
			m.push(new Codeword(row,field_size));
		}
		return m;
	}

	codewords.hamming_square_encode = function(word) {
		var n = Math.sqrt(word.length);

		var column_sums = [];
		var out = [];
		var total = 0;
		for(var i=0;i<n;i++) {
			var row_sum = 0;
			var column_sum = 0;
			for(var j=0;j<n;j++) {
				row_sum += word.digits[n*i+j];
				column_sum += word.digits[n*j+i];
				out.push(word.digits[n*i+j]);
			}
			out.push(row_sum % 2);
			total += row_sum;
			column_sums.push(column_sum % 2);
		}
		out = out.concat(column_sums);
		out.push(total % 2);
		return new Codeword(out,2);
	}

	codewords.hamming_square_decode = function(word) {
		var n = Math.sqrt(word.length);

		var rows = [];
		for(var i=0;i<n;i++) {
			rows.push(word.digits.slice(n*i,(n+1)*i));
		}
		var row_errors = [];
		var column_errors = [];
		for(var i=0;i<n-1;i++) {
			var row_sum = 0;
			var column_sum = 0;
			for(var j=0;j<n-1;j++) {
				row_sum += word.digits[n*i+j];
				column_sum += word.digits[n*j+i];
			}
			row_errors.push(row_sum % 2 != word.digits[n*i+n-1]);
			column_errors.push(column_sum % 2 != word.digits[n*(n-1)+i]);
		}
		var out = [];
		console.log(row_errors);
		console.log(column_errors);
		for(var i=0;i<n-1;i++) {
			for(var j=0;j<n-1;j++) {
				var c = word.digits[n*i+j];
				if(row_errors[i] && column_errors[j]) {
					c = 1-c;
				}
				out.push(c);
			}
		}
		return new Codeword(out,2);
	};


	/// JME stuff
	if(Numbas.jme) {
	
	var TCodeword = Numbas.jme.types.codeword = Numbas.jme.types.TCodeword= function(codeword) {
		this.value = codeword;
	};
	TCodeword.prototype.type = 'codeword';

	Numbas.jme.display.typeToTeX.codeword = function(thing,tok,texArgs,settings) {
		return tok.value+'';
	};

	Numbas.jme.display.typeToJME.codeword = function(tree,tok,bits,settings) {
		return tok.value+'';
	}

	var funcObj = Numbas.jme.funcObj;
	var TString = Numbas.jme.types.TString;
	var TNum = Numbas.jme.types.TNum;
	var TList = Numbas.jme.types.TList;
	var TBool = Numbas.jme.types.TBool;
	var TMatrix = Numbas.jme.types.TMatrix;

	codewords.scope.addFunction(new funcObj('codeword',[TString,TNum],TCodeword,function(word,field_size) {
		return Codeword.fromString(word,field_size) ;
	}));
	codewords.scope.addFunction(new funcObj('codeword',[TList,TNum],TCodeword,function(digits,field_size) {
		digits = digits.map(function(i){ return i.value; });
		return new Codeword(digits,field_size) ;
	}));

	codewords.scope.addFunction(new funcObj('+',[TCodeword,TCodeword],TCodeword,function(w1,w2) {
		return w1.add(w2);
	}));
	codewords.scope.addFunction(new funcObj('-',[TCodeword,TCodeword],TCodeword,function(w1,w2) {
		return w1.sub(w2);
	}));
	codewords.scope.addFunction(new funcObj('+u',[TCodeword],TCodeword,function(w) {
		return w;
	}));
	codewords.scope.addFunction(new funcObj('-u',[TCodeword],TCodeword,function(w) {
		return w.negate();
	}));

	codewords.scope.addFunction(new funcObj('*',[TCodeword,TNum],TCodeword,function(w,f) {
		return w1.scale(f);
	}));

	codewords.scope.addFunction(new funcObj('*',[TNum,TCodeword],TCodeword,function(w,f) {
		return w1.scale(f);
	}));

	codewords.scope.addFunction(new funcObj('listval',[TCodeword,TNum],TNum,function(w,i) {
		return w.digits[i];
	}));

	codewords.scope.addFunction(new funcObj('allwords',[TNum,TNum],TList,function(n,field_size) {
		var words = codewords.allwords(n,field_size).map(function(c){return new TCodeword(c)});
		return words;
	}));

	codewords.scope.addFunction(new funcObj('set_generated_by',[TList],TList,function(basis) {
		return codewords.set_generated_by(basis).map(function(c){return new TCodeword(c)});
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('linearly_independent',[TList],TBool,function(words) {
		return codewords.linearly_independent(words);
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('coset_containing',[TCodeword,TList],TList,function(word,basis) {
		return codewords.coset_containing(word,basis).map(function(c){return new TCodeword(c)});
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('sleppian_array',[TList],TList,function(basis) {
		var sleppian = codewords.sleppian_array(basis).map(function(row){return row.map(function(c){return new TCodeword(c)})});
		return sleppian;
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('is_coset_leader',[TCodeword,TList],TBool,function(word,basis) {
		return codewords.is_coset_leader(word,basis);
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('parity_check_matrix',[TList],TList,function(basis) {
		return codewords.parity_check_matrix(basis).map(function(c){return new TCodeword(c)});
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('reduced_row_echelon_form',[TList],TList,function(basis) {
		return codewords.reduced_row_echelon_form(basis).map(function(c){return new TCodeword(c)});
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('codeword_matrix',[TList],TMatrix,function(words) {
		var matrix = words.map(function(w){return w.digits});
		matrix.rows = words.length;
		matrix.columns = matrix[0].length;
		return new TMatrix(matrix);
	},{unwrapValues: true}));

	codewords.scope.addFunction(new funcObj('hamming_square_encode',[TCodeword],TCodeword,function(word) {
		return codewords.hamming_square_encode(word);
	});

	codewords.scope.addFunction(new funcObj('hamming_square_decode',[TCodeword],TCodeword,function(word) {
		return codewords.hamming_square_decode(word);
	});
	}

	///////// demo

	/*
	var words = allwords(5,3);
	console.log(words.join(','));

	var basis = [words[1],words[3],words[5]];
	console.log('basis:',basis.join(','));
	var combs = set_generated_by(basis);
	console.log('set generated: ',combs.join(','));
	console.log('linearly independent? ',linearly_independent([words[1],words[3]]));

	var w = Codeword.fromString('00110',3);
	var c = coset_containing(w,basis);
	console.log('coset generated by '+w+': '+c.join(','));
	console.log('is coset leader? '+is_coset_leader(w,basis));

	var sleppian = sleppian_array(basis);
	console.log('sleppian array');
	console.log(sleppian.map(function(cs){return cs.join(',');}).join('\n'));
	*/
});
