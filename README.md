Linear codes extension for Numbas
==========================

This extension provides a new data type and some functions to deal with linear codes.

JME functions
-------------

### `codeword(digits,field_size)`

Create a codeword from a list of digits, in Z_{field_size}. For example, `codeword([1,1,0,1],2)`

### `codeword(word_string,field_size)`

Create a codeword from a string of digits, in Z_{field_zie}. For example, `codeword("11001",2)`

### `word1+word2`

Add two codewords. 

### `word1-word2`

Subtract one codeword from another

### `n*word` or `word*n`

Multiply a codeword by a scalar

### `allwords(word_length,field_size)`

Generate a list of all codewords of given length in Z_{field_size}.

### `set_generated_by(basis)`

Returns the set of codewords generated by the given list of basis codewords.

### `linearly_independent(basis)`

Are the given codewords linearly independent? (Not sure if this is correctly implemented - it just checks that the set generated by the basis contains `(field_size)^(number of basis words)` words)

### `coset_containing(word,basis)`

Generate the coset containing the given word, with respect to the given generating set.

### `sleppian_array(basis)`

Generate the Sleppian array corresponding to the given basis set. Each row in the result is a coset, sorted by weight.

### `is_coset_leader(word,basis)`

Is the given word a coset leader in its coset? That is, does it have the minimum weight?

### `parity_check_matrix(basis)`

Create a parity check matrix for the given generating set, by putting it in reduced row-echelon form `I_n|A` and returning `A_transpose|I_(m)`.

### `reduced_row_echelon_form(basis)`

Put the given list of words (interpreted as a matrix) into reduced row-echelon form.

### `codeword_matrix(words)`

Returns a matrix whose rows are the given codewords.

### `hamming_square_encode(word)`

Encode `word` using Hamming's square code.

### `hamming_square_decode(word)`

Decode (and correct up to one error in) `word` using Hamming's square code.

### `hamming_encode(word)`

Encode `word` using the general Hamming code.

### `hamming_decode(word)`

Decode (and correct up to one error in) `word` using the general Hamming code.

### `make_error(word,n)`

Introduce an error in digit `n` of `word` - return a word which differs in that digit.
